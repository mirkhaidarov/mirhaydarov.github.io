{"version":3,"sources":["../../src/create-form-unit.ts","../../src/field.ts","../../src/validation.ts","../../src/factory.ts","../../src/react-hooks.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../effector/is.ts","../effector/createNode.ts","../effector/tag.ts","../effector/kernel.ts","../effector/naming.ts","../effector/collection.ts","../effector/createUnit.ts","../effector/combine.ts","../effector/defer.ts","../effector/createEffect.ts","../effector/merge.ts","../effector/sample.ts","../effector/guard.ts","../effector/restore.ts","../effector/observable.ts","../effector/validate.ts","../effector/throw.ts","../effector/id.ts","../effector/bind.ts","../effector/step.ts","../effector/stateRef.ts","../effector/caller.ts","../effector/getter.ts","../effector/own.ts","../effector/region.ts","../effector/config.ts","../effector/clearNode.ts","../effector/subscription.ts","../effector/forward.ts","../effector/watch.ts","../effector-react/useStore.ts","../effector-react/useIsomorphicLayoutEffect.ts","../effector-react/throw.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"],"names":["createFormUnit","existing","init","domain","store","createStore","event","createEvent","createField","fieldName","fieldConfig","initValue","$value","units","$errors","$firstError","map","errors","$isDirty","value","$touched","$isTouched","onChange","onBlur","changed","addError","validate","resetErrors","resetValue","reset","$isValid","firstError","name","$field","combine","isValid","isDirty","isTouched","set","filter","bindValidation","fieldValidationEvents","rulesOrResolver","$form","validateFormEvent","submitEvent","resetFormEvent","resetValues","field","rules","resetErrorsFormEvent","formValidationEvents","rulesSources","source","validator","form","i","length","rule","result","push","errorText","eventsNames","validationEvents","includes","validationTrigger","sample","fieldValue","clock","merge","addErrorWithValue","fn","on","_","newError","bindChangeEvent","setForm","resetForm","resetTouched","guard","target","curr","updateSet","hasOwnProperty","createForm","config","$filter","fieldsConfigs","fields","validateOn","dirtyFlagsArr","touchedFlagsArr","shape","$eachValid","firstErrors","every","error","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","$meta","touched","submitForm","submit","formValidated","submitWithFormData","validateWithFormData","$values","useField","useStore","hasError","useForm","connectedFields","values","connectedField","eachValid","_slicedToArray","arr","Array","isArray","Symbol","iterator","Object","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","unsupportedIterableToArray","TypeError","_createForOfIteratorHelper","o","allowArrayLike","it","F","s","n","e","f","normalCompletion","didErr","step","_e2","assertNodeSetItem","method","valueName","reason","isObject","isFunction","throwError","assertNodeSet","createNode","node","from","parent","to","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","reg","item","addToReg","id","nextNodeID","getOwners","getLinks","regionStack","own","getValue","launch","unit","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","pushFirstHeapItem","getGraph","isRoot","stop","skip","lastStartedState","isWatch","kernelLoop","deleteMin","idx","stack","local","fail","stepn","data","barrierID","fullID","priority","barriers","has","add","pushHeap","delete","STORE","getPageForRef","readRef","getPageRef","current","tryRun","op","unitObjectName","objOrArr","comma","key","is","compositeName","fullName","toString","createName","path","composite","shortName","concat","forIn","obj","cb","forEach","list","nameOrConfig","maybeConfig","args","template","oldPage","getParent","setCurrentPage","create","graphite","initUnit","find","watch","bind","watchUnit","mapped","mapName","createComputation","MAP","createEventFiltration","callStack","filterMap","defined","prepend","contramapped","readTemplate","upward","applyParentHook","defaultState","props","onEvent","off","getSubscribers","createSubscription","updateStore","updateFilter","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","nodeMap","nodeSet","currentSubscription","get","firstState","lastResult","storeState","innerStore","strict","linkNode","getStoreState","before","loader","unshift","eventOrFn","subscription","of","defaultConfig","update","a","isStrict","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","rawHandler","slice","spreadArgs","storeCombination","createDefer","req","Promise","rs","rj","catch","createEffect","instance","getType","onCopy","kind","use","anyway","finally","named","status","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","upd","savedFork","setForkPage","inFlight","x","pending","amount","events","forward","sid","greedy","processArgsToConfig","metadata","atLeastOneFieldExists","sampleConfigFields","needToCombine","isUpward","targetTemplate","nativeTemplate","sourceRef","createLinkNode","callARegStack","closure","hasSource","sourceState","clockState","callStackAReg","rawName","filterIsUnit","restore","É”","v","hooks","observableSymbol","observable","EFFECT","effect","message","Error","assertObject","idCount","nextUnitID","nextStepID","bind2","arg","cmd","hasRef","nextBarrierID","barrier","mov","check","compute","run","graph","getConfig","opts","getNestedConfig","val","ownerUnit","owner","link","readSidRoot","sidRoot","heap","b","ret","isSameType","r","l","queue","ix","first","last","size","getPriority","bucket","t","Set","newForkPage","newPage","console","joinName","tag","rawConfig","injected","removeItem","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","forkedNode","normalizeConfig","part","loc","hookType","rawConfigA","rawConfigB","isDomain","unitId","thru","subscribe","observer","stateFirst","storeRef","ref","clone","stateNew","rawShape","isFresh","isCombine","childRef","defaultShape","sidechain","currentValue","inc","React","useReducer","currentStore","useRef","useIsomorphicLayoutEffect","newValue","window","useLayoutEffect","useEffect","_unsupportedIterableToArray","minLen","prototype","call","constructor","test","_toConsumableArray","arrayLikeToArray","iter","_arrayLikeToArray","len","arr2"],"mappings":"uOA2BaA,EAnBb,YAAsCC,IAAdC,EAAcD,EAAhBC,KAAQC,EAAQF,EAAVE,OACxB,OADkCF,EAAFA,WAIzBE,EAASA,EAAOC,MAAMF,GAAQG,YAAYH,KAexCF,EAPb,YAAgCC,IAARE,EAAQF,EAAVE,OAClB,OAD4BF,EAAFA,WAInBE,EAASA,EAAOG,QAAiBC,yBCD5BC,EACZC,EACAC,EACAP,6BAEMQ,EAAwC,mBAArBD,EAAYR,KAC/BQ,EAAYR,OACZQ,EAAYR,KAEZU,EAASZ,EAAqB,CAChCG,SACAF,mBAAUS,EAAYG,4BAAOD,OAC7BV,KAAMS,IAGJG,EAAUd,EAAwC,CACpDG,SACAF,mBAAUS,EAAYG,4BAAOC,QAC7BZ,KAAM,KAIJa,EAAcD,EAAQE,KACvBC,mBAAWA,EAAO,GAAKA,EAAO,GAAK,QAGlCC,EAAWN,EAAOI,KAAKG,mBAAUA,IAAUR,KAE3CS,EAAWpB,EAAqB,CAClCG,SACAF,mBAAUS,EAAYG,4BAAOQ,WAC7BnB,UAGEoB,EAAWtB,EAAqB,CAClCG,SACAF,mBAAUS,EAAYG,4BAAOS,WAE3BC,EAASvB,EAAqB,CAChCG,SACAF,mBAAUS,EAAYG,4BAAOU,SAE3BC,EAAUxB,EAAqB,CACjCG,SACAF,mBAAUS,EAAYG,4BAAOW,UAE3BC,EAAWzB,EAGd,CACCG,SACAF,mBAAUS,EAAYG,4BAAOY,WAE3BC,EAAW1B,EAAqB,CAClCG,SACAF,mBAAUS,EAAYG,4BAAOa,WAE3BC,EAAc3B,EAAqB,CACrCG,SACAF,mBAAUS,EAAYG,4BAAOc,cAE3BC,EAAa5B,EAAqB,CACpCG,SACAF,mBAAUS,EAAYG,4BAAOe,aAE3BC,EAAQ7B,EAAqB,CAC/BG,SACAF,mBAAUS,EAAYG,4BAAOgB,QAG3BC,EAAWf,EAAYC,KAAKe,mBAA8B,OAAfA,KAWjD,MAAO,CACHP,UACAQ,KAAMvB,EACNG,SACAE,UACAC,cACAe,WACAZ,WACAG,WAAYD,EACZA,WACAa,OAnBWC,YAAQ,CACnBf,MAAOP,EACPK,OAAQH,EACRiB,WAAYhB,EACZoB,QAASL,EACTM,QAASlB,EACTmB,UAAWjB,IAcXE,WACAC,SACAE,WACAC,WACAY,IAAKhB,EACLO,QACAF,cACAC,aACAW,OAAQ7B,EAAY6B,iBAiBZC,EAjBYD,GA2BxBE,IC7IAC,EDoIAC,EASAF,EAV2BE,MAE3BC,EAQAH,EATKG,kBAELC,EAOAJ,EARiBI,YAEjBC,EAMAL,EAPWK,eAEXC,EAKAN,EANcM,YAEdC,EAIAP,EALWO,MAEXC,EAGAR,EAJKQ,MAEQC,EAEbT,EAFAd,YACAwB,EACAV,EAFiCU,qBAEjCV,IADoBA,sBAIhB7B,EASAoC,EAVEpC,OAEFE,EAQAkC,EATMlC,QAENS,EAOAyB,EAROzB,OAEPC,EAMAwB,EAPMxB,QAENC,EAKAuB,EANOvB,SAEPC,EAIAsB,EALQtB,SAERC,EAGAqB,EAJQrB,YAERC,EAEAoB,EAHWpB,WAEXC,EACAmB,EAFUnB,MAIRuB,EAAgC,mBAAVH,EACtB5C,YAAmB,IACnB6B,YAAQe,EAAMjC,KAAI,qBAAGqC,QAAuBhD,YAAY,UAExDiD,GC/JNZ,ED+JyCO,EC7JlC,SACH9B,EACAoC,EACAH,GAQA,IALA,IAAMnC,EAAmC,GACnCgC,EAAmC,mBAApBP,EACfA,EAAgBvB,EAAOoC,GACvBb,EAEGc,EAAI,EAAGA,EAAIP,EAAMQ,OAAQD,IAAK,CACnC,IAAME,EAAOT,EAAMO,GACbH,EAASD,EAAeA,EAAaI,GAAK,KAC1CG,EAASD,EAAKJ,UAAUnC,EAAOoC,EAAMF,GAErB,kBAAXM,GAAyBA,GAChC1C,EAAO2C,KAAK,CACRF,KAAMA,EAAK1B,KACX6B,UAAWH,EAAKG,UAChB1C,UAIc,iBAAXwC,GAAwBA,EAAOxB,SACtClB,EAAO2C,KAAK,CACRF,KAAMA,EAAK1B,KACX6B,UAAWF,EAAOE,UAClB1C,UAKZ,OAAOF,ID6HL6C,wBAAkBX,GAAlBW,YAA2CrB,IAC3CsB,EAIC,GAEP,GAAID,EAAYE,SAAS,UAAW,CAChC,IAAMC,EAAoBC,YAAO,CAC7Bb,OAAQnB,YAAQ,CACZiC,WAAYvD,EACZ2C,KAAMZ,EACNS,iBAEJgB,MAAOvB,IAGXkB,EAAiBH,KAAKK,GAGtBH,EAAYE,SAAS,SACrBD,EAAiBH,KAAKM,YAAO,CACzBb,OAAQnB,YAAQ,CACZiC,WAAYvD,EACZ2C,KAAMZ,EACNS,iBAEJgB,MAAO7C,KAIXuC,EAAYE,SAAS,WACrBD,EAAiBH,KAAKM,YAAO,CACzBb,OAAQnB,YAAQ,CACZiC,WAAYvD,EACZ2C,KAAMZ,EACNS,iBAEJgB,MAAOC,YACH,CAAC7C,EAASI,EAAYmB,OAKlCgB,EAAiBH,KAAKM,YAAO,CACzBb,OAAQnB,YAAQ,CACZiC,WAAYvD,EACZ2C,KAAMZ,EACNS,iBAEJgB,MAAO1C,KAGXqC,EAAiBH,KAAKM,YAAO,CACzBb,OAAQnB,YAAQ,CACZiC,WAAYvD,EACZ2C,KAAMZ,EACNS,iBAEJgB,MAAOxB,KAGX,IAAM0B,EAAoBJ,YAAO,CAC7Bb,OAAQzC,EACRwD,MAAO3C,EACP8C,GAAI,SAACpD,EAAD,SAAgB0C,CAChBH,KADA,EAAUA,KAEVvC,QACA0C,UAHA,EAAgBA,cAOxB/C,EACK0D,GACGT,GACA,SAACU,EAAD,OAAMlB,EAAN,EAAMA,KAAMY,EAAZ,EAAYA,WAAYf,EAAxB,EAAwBA,aAAxB,OAA2CE,EACvCa,EACAZ,EACAH,MAGPoB,GAAGF,GAAmB,SAACrD,EAAQyD,GAAT,OAAuBA,GAAvB,mBAAoCzD,OAC1DY,MAAMF,EAAamB,EAAgBjB,EAAOqB,GAE1CY,EAAYE,SAAS,WACtBlD,EAAQe,MAAML,YAINmD,EAJMnD,EAclBoD,EACAC,EACAC,EACA/B,OAXInC,EAWJmC,EAZAnC,OAEIQ,EAUJ2B,EAXU3B,SAENE,EASJyB,EAVYzB,SAERE,EAQJuB,EATYvB,QAERQ,EAOJe,EARWf,KAEPH,EAMJkB,EAPQlB,MAEJD,EAKJmB,EANSnB,WAELW,EAIJQ,EALcR,OAQdnB,EACKoD,GAAGhD,GAAS,uBACZK,MAAMA,EAAOgD,EAAWC,GAE7BC,YAAM,CACF1B,OAAQ/B,EACRiB,OAAQA,wBACRyC,OAAQxD,IAGZZ,EACK4D,GAAGhD,GAAS,SAACiD,EAAGtD,GAAJ,OAAcA,KAC1BqD,GACGI,GACA,SAACK,EAAMC,GAAP,OAAqBA,EAAUC,eAAenD,GACxCkD,EAAUlD,GACViD,KAETpD,MAAMA,EAAOD,EAAYmB,EAAa8B,YElO/BO,EACZC,OAGYC,EAKRD,EALA9C,OACApC,EAIAkF,EALelF,OAEPoF,EAGRF,EAHAG,OACAC,EAEAJ,EAHqBI,WAErB5E,EACAwE,EAFUxE,MAIR2E,EAAoB,GAEpBE,EAAkC,GAClCC,EAAoC,GAG1C,IAAK,IAAMlF,KAAa8E,EACpB,GAAKA,EAAcJ,eAAe1E,GAAlC,CAEA,IAEMuC,EAAQxC,EAAYC,EAFN8E,EAAc9E,GAEgBN,GAElDqF,EAAO/E,GAAauC,EACpB0C,EAAc9B,KAAKZ,EAAM9B,UACzByE,EAAgB/B,KAAKZ,EAAM5B,UAG/B,IAAMuB,EAvEV,SACI6C,GAEA,IAAMI,EAAuC,GAE7C,IAAK,IAAMnF,KAAa+E,EACfA,EAAOL,eAAe1E,KAC3BmF,EAAMnF,GAAa+E,EAAO/E,GAAWG,QAGzC,OAAOsB,YAAQ0D,GAVnB,CAuEwCJ,GAC9BK,WD/CgBL,GACtB,IAAMM,EAA+C,GAErD,IAAK,IAAMrF,KAAa+E,EACpB,GAAKA,EAAOL,eAAe1E,GAA3B,CAD4B,IAEpBM,EAAgByE,EAAO/E,GAAzBM,YACN+E,EAAYlC,KAAK7C,GAKrB,OAFqBmB,YAAQ4D,GAET9E,KAAKC,mBAAWA,EAAO8E,OAAMC,mBAAmB,OAAVA,QCoCpDH,CAAuBL,GACvBS,EAAeX,EACfpD,YAAQ2D,EAAYP,GAAS,SAACY,EAAO3D,GAAR,OAAmB2D,GAAS3D,KACzDsD,EACA3E,EAAWgB,YAAQwD,GAAe1E,KACnCmF,mBAAeA,EAAWC,KAAKC,YAE9BjF,EAAWc,YAAQyD,GAAiB3E,KACrCsF,mBAAiBA,EAAaF,KAAKC,YAGlCE,EAAQrE,YAAQ,CAClBC,QAAS0D,EACTzD,QAASlB,EACTsF,QAASpF,IAGPM,EAAW1B,EAA2B,CACxCG,SACAF,SAAUY,iBAAOa,WAGf+E,EAAazG,EAA2B,CAC1CG,SACAF,SAAUY,iBAAO6F,SAGfC,EAAgB3G,EAAqB,CACvCG,SACAF,SAAUY,iBAAO8F,gBAIf/B,EAAU5E,EAA6C,CACzDG,SACAF,SAAUY,iBAAO+D,UAGfC,EAAY7E,EAAqB,CACnCG,SACAF,SAAUY,iBAAOgB,QAGfkB,EAAc/C,EAAqB,CACrCG,SACAF,SAAUY,iBAAOkC,cAGfpB,EAAc3B,EAAqB,CACrCG,SACAF,SAAUY,iBAAOc,cAGfmD,EAAe9E,EAAqB,CACtCG,SACAF,SAAUY,iBAAOiE,eAGf8B,EAAqB1C,YAAOvB,EAAO8D,GACnCI,EAAuB3C,YAAOvB,EAAOjB,GAG3C,IAAK,IAAMjB,KAAa+E,EACpB,GAAKA,EAAOL,eAAe1E,GAA3B,CAEA,IAAMC,EAAc6E,EAAc9E,GAC5BuC,EAAQwC,EAAO/E,GAErBkE,EAAgB3B,EAAO4B,EAASC,EAAWC,EAAc/B,GAEpDrC,EAAYuC,OAEjBT,EAAe,CACXG,QACAM,MAAOvC,EAAYuC,MACnBJ,YAAa4D,EACb3D,eAAgB+B,EAChB9B,cACApB,cACAiB,kBAAmBlB,EACnBsB,QACAG,qBAAsBsC,GAA0B,CAAC,UACjDhD,sBAAuB/B,EAAY+E,WAC7B/E,EAAY+E,WACZ,KAiBd,OAbAV,YAAM,CACF1B,OAAQuD,EACRrE,OAAQ0D,EAERjB,OAAQ2B,IAGZ5B,YAAM,CACF1B,OAAQwD,EACRtE,OAAQ0D,EACRjB,OAAQ2B,IAGL,CACHnB,SACAsB,QAASnE,EACTkD,aACA/D,SAAU+D,EACV3E,SAAUA,EACVE,SAAUA,EACVmF,QACAG,OAAQD,EACR/E,WACAoD,eACAjD,MAAOgD,EACP9B,cACApB,cACAiD,UACAtC,IAAKsC,EACL+B,0BCvKQI,EAAgB/D,SAQxBgE,YAAShE,EAAMf,QANfd,EAFwB6B,EACtB7B,MAEFF,EAHwB+B,EAEnB/B,OAELc,EAJwBiB,EAGlBjB,WAENI,EALwBa,EAIdb,QAEVC,EANwBY,EAKjBZ,QAEIoE,EAPaxD,EAOxBX,UAGJ,MAAO,CACHL,KAAMgB,EAAMhB,KACZb,QACAF,SACAc,aACAI,UACAC,UACAoE,UACAnE,UAAWmE,EACXlF,SAAU0B,EAAM1B,SAChBC,OAAQyB,EAAMzB,OACdE,SAAUuB,EAAMvB,SAChBC,SAAUsB,EAAMtB,SAChBG,MAAOmB,EAAMnB,MACbS,IAAKU,EAAM1B,SACXK,YAAaqB,EAAMrB,YACnBsF,SAAU,kBACgB,OAAflF,GAEX8B,UAAY7C,mBACHe,EAGAf,GAGDA,EAAIe,EAAW2B,MACR1C,EAAIe,EAAW2B,MAHf3B,EAAW8B,WAAa,GAHxB,cAuCPqD,EACZ3D,GAEA,IAAM4D,EAAkB,GAClBC,EAAS,GAEf,IAAK,IAAM3G,KAAa8C,EAAKiC,OACzB,GAAKjC,EAAKiC,OAAOL,eAAe1E,GAAhC,CACA,IACM4G,EAAiBN,EADTxD,EAAKiC,OAAO/E,IAE1B0G,EAAgB1G,GAAa4G,EAC7BD,EAAO3G,GAAa4G,EAAelG,MAVvCoC,MAiBIyD,YAASzD,EAAKgD,OAHLe,EAdb/D,EAcIpB,QACAC,EAfJmB,EAcsBnB,QAElBoE,EAhBJjD,EAeWiD,QA8CX,MAAO,CACHhB,OAAQ2B,EACRC,SACAH,SA5CcxG,mBACTA,IAGD0G,EAAgB1G,IACT4F,QAAQc,EAAgB1G,GAAWsB,aAHlCuF,GA2CZA,YACAnF,QAASmF,EACTlF,UACAC,UAAWmE,EACXA,UACAvF,OAjCYR,mBACR0G,EAAgB1G,GACT0G,EAAgB1G,GAAWQ,OAE/B,IA8BP+E,MAzCWvF,mBACP0G,EAAgB1G,GACT0G,EAAgB1G,GAAWsB,WAE/B,MAsCPF,MAAO0B,EAAK1B,MACZgC,UA7Bc,SAACpD,EAAmBO,GAClC,IAAMgC,EAAQmE,EAAgB1G,GAC9B,OAAKuC,GAGAA,EAAMjB,WAGNf,GAGDA,EAAIgC,EAAMjB,WAAW2B,MACd1C,EAAIgC,EAAMjB,WAAW2B,MAHrBV,EAAMjB,WAAW8B,WAAa,GAN9B,IA2BX6C,OAAQnD,EAAKmD,OACb9B,QAASrB,EAAKqB,QACdtC,IAAKiB,EAAKqB,QACV+B,cAAepD,EAAKoD,iB,+aC9Lb,SAASY,EAAeC,EAAKhE,GAC1C,OCLa,SAAyBgE,GACtC,GAAIC,MAAMC,QAAQF,GAAM,OAAOA,EDIxB,CAAeA,IELT,SAA+BA,EAAKhE,GACjD,GAAsB,qBAAXmE,QAA4BA,OAAOC,YAAYC,OAAOL,GAAjE,CACA,IAAIM,EAAO,GACPC,GAAK,EACLC,GAAK,EACLC,OAAKC,EAET,IACE,IAAK,IAAiCC,EAA7BC,EAAKZ,EAAIG,OAAOC,cAAmBG,GAAMI,EAAKC,EAAGC,QAAQC,QAChER,EAAKlE,KAAKuE,EAAGhH,QAETqC,GAAKsE,EAAKrE,SAAWD,GAH8CuE,GAAK,IAK9E,MAAOQ,GACPP,GAAK,EACLC,EAAKM,EACL,QACA,IACOR,GAAsB,MAAhBK,EAAW,QAAWA,EAAW,SAC5C,QACA,GAAIJ,EAAI,MAAMC,GAIlB,OAAOH,GFnBuB,CAAqBN,EAAKhE,IAAM,OAAAgF,EAAA,GAA2BhB,EAAKhE,IGLjF,WACb,MAAM,IAAIiF,UAAU,6IHIgF,G,YIJvF,SAASC,EAA2BC,EAAGC,GACpD,IAAIC,EAEJ,GAAsB,qBAAXlB,QAAgD,MAAtBgB,EAAEhB,OAAOC,UAAmB,CAC/D,GAAIH,MAAMC,QAAQiB,KAAOE,EAAK,OAAAL,EAAA,GAA2BG,KAAOC,GAAkBD,GAAyB,kBAAbA,EAAElF,OAAqB,CAC/GoF,IAAIF,EAAIE,GACZ,IAAIrF,EAAI,EAEJsF,EAAI,aAER,MAAO,CACLC,EAAGD,EACHE,EAAG,WACD,OAAIxF,GAAKmF,EAAElF,OAAe,CACxB6E,MAAM,GAED,CACLA,MAAM,EACNnH,MAAOwH,EAAEnF,OAGbyF,EAAG,SAAWhB,GACZ,MAAMA,GAERiB,EAAGJ,GAIP,MAAM,IAAIL,UAAU,yIAGtB,IAEIF,EAFAY,GAAmB,EACnBC,GAAS,EAEb,MAAO,CACLL,EAAG,WACDF,EAAKF,EAAEhB,OAAOC,aAEhBoB,EAAG,WACD,IAAIK,EAAOR,EAAGR,OAEd,OADAc,EAAmBE,EAAKf,KACjBe,GAETJ,EAAG,SAAWK,GACZF,GAAS,EACTb,EAAMe,GAERJ,EAAG,WACD,IACOC,GAAoC,MAAhBN,EAAW,QAAWA,EAAW,SAC1D,QACA,GAAIO,EAAQ,MAAMb,KCvC1B,SAASgB,EAAkBpI,EAAYqI,EAAgBC,EAAmBC,IAClEC,EAASxI,IAAWyI,EAAWzI,MAAc,WAAYA,GAAY,aAAcA,IACvF0I,YAAcL,EAAdK,oBAAgCJ,EAAhCI,iDAAkFH,IAG/E,SAASI,EAAc3I,EAAYqI,EAAgBC,MACpDhC,MAAMC,QAAQvG,OACX,IAAIqC,EAAI,EAAGA,EAAIrC,EAAMsC,OAAQD,IAEhC+F,EADapI,EAAMqC,GACKgG,EAAxBD,UAAmC/F,EAAnC+F,oBAAgDE,GAAa,SAG/DF,EAAkBpI,EAAOqI,EAAQC,EAAW,sBCUzC,SAASM,IAiCwB,IALpC,oEA5BuBC,KACzBA,OA2BE,MA3BK,GA2BL,EA1BFC,EA0BE,EA5BuBD,KAGzB3G,EAyBE,EA5BuB2G,OA4BvB,IA5BuBA,OAIzBE,OAwBE,MAxBOD,GAAQ5G,EAwBf,EAvBF8G,EAuBE,EA5BuBH,GAMzBhF,EAsBE,EA5BuBgF,OA4BvB,IA5BuBA,MAOzBI,OAqBE,MArBMD,GAAMnF,EAqBZ,MA5BuBgF,MAQzBK,OAoBE,MApBM,GAoBN,MA5BuBL,KASzBM,OAmBE,MAnBK,GAmBL,MAlBFC,OAAQC,OAkBN,MAlBkB,CAACC,KAAM,WAkBzB,EAjBFC,EAiBE,EA5BuBV,SA6BnBW,EAAUC,GAAYV,GACtBW,EAAQD,GAAYJ,EAAUK,OAC9BC,EAASF,GAAYJ,EAAUM,QAC/BC,EAAa,GACbC,EAAgC,GAC7BxH,EAAI,EAAGA,EAAIwG,EAAKvG,OAAQD,IAAK,KAC9ByH,EAAOjB,EAAKxG,GACbyH,IACLF,EAAInH,KAAKqH,GACTC,GAASD,EAAMD,IAafA,IAbeA,IAEXrH,EAAe,CACnBwH,GAAIC,IACJL,MACA1C,KAAMuC,GAAYR,GAClBE,OACAD,QACAE,OAAQ,CACNE,KAAMD,EAAUC,MC7EG,YD8EnBI,QACAC,UAEFE,OAEOxH,EAAI,EAAGA,EAAIqH,EAAMpH,OAAQD,IAChC6H,GAAUR,EAAMrH,IAAII,KAAKD,OAEtB,IAAIH,EAAI,EAAGA,EAAIsH,EAAOrH,OAAQD,IACjC8H,GAASR,EAAOtH,IAAII,KAAKD,OAEtB,IAAIH,EAAI,EAAGA,EAAImH,EAAQlH,OAAQD,IAClCmH,EAAQnH,GAAG6E,KAAKzE,KAAKD,UAEnB+G,GAAYa,IACdC,GAAIC,GAASF,IAAc,CAAC5H,IAEvBA,EEmIF,SAAS+H,EAAOC,EAAWC,EAAeC,OAC3CC,EAAgBC,GAChBC,EAAiB,KACjBC,EAAoBC,MACpBP,EAAK3G,SACP4G,EAAUD,EAAKQ,OACfN,EAASF,EAAKS,MACdN,EAAgB,SAAUH,EAAOA,EAAKU,KAAOP,EACzCH,EAAI,QAASK,EAAiBL,EAAI,OACtCM,EAAoBK,GAAYX,IAASM,EACzCN,EAAOA,EAAK3G,QAEViH,GAAqBC,IAAYD,IAAsBC,KACzDA,GAAW,MAETzE,MAAMC,QAAQiE,OACX,IAAInI,EAAI,EAAGA,EAAImI,EAAKlI,OAAQD,IAC/B+I,GACE,OACAT,EACAU,GAASb,EAAKnI,IACdwI,EACAJ,EAAQpI,GACRyI,QAIJM,GACE,OACAT,EACAU,GAASb,GACTK,EACAJ,EACAK,OAGAJ,GAAWY,GAHXR,CAGmB,IAInBS,EACAC,EACA3C,EACA7I,EACAkL,EACArB,EAPE4B,EAAmB,CAACH,UAAQV,eAAaG,YAAUW,YACzDJ,GAAS,EAOTK,EAAY,KAAQ3L,EAAQ4L,MAAc,OACb5L,EAApB6L,EADiC,EAClCA,IAAMC,EAD4B,EAClCD,MAAavC,EADqB,EAClCuC,KACNhD,EAAOiD,EAAMjD,KACb+B,GAAcM,EAAOY,EAAMZ,KAC3BH,GAAWI,GAAYW,GACvBjC,GAAOqB,GAAcrC,GAAMgB,QACrBkC,EAAe,CACnBC,KAAM,EACN9C,MAAOL,EAAKK,OAEdqC,EAAOC,EAAO,MACT,IAAIS,EAAQJ,EAAKI,EAAQpD,EAAKe,IAAItH,SAAWiJ,EAAMU,IAAS,KACzD/D,EAAOW,EAAKe,IAAIqC,GAChBC,EAAOhE,EAAKgE,YACVhE,EAAKoB,UD3RI,cC6RTU,EAAKkC,EAAKC,UACVjB,IACFlB,YAAQkB,EAAKkB,OAAbpC,YAAuBA,QAEnBqC,EAAWH,EAAKG,YAClBJ,IAAUJ,GAAOvC,IAAS+C,EAAU,CACjCC,GAASC,IAAIvC,KAChBsC,GAASE,IAAIxC,GACbyC,GAASR,EAAOH,EAAOO,EAAUrC,aAE1B2B,EAEXW,GAASI,OAAO1C,aAGb,UACChK,gBAEIkM,EAAKpD,UDhTF,QCiTG9I,EAAQsK,GAASwB,aD3SpB,QC6SJ,IACH9L,EAAQ8L,EAAMI,EAAKpD,gBDlTZ,QCoTG9I,EAAQkM,EAAKjN,iBACpB0N,EACE9C,EAAIqC,EAAKjN,MAAM+K,MAElB8B,EAAMZ,KAAOA,EAAO0B,GAAc1B,EAAMgB,EAAKjN,MAAM+K,IACnDH,EAAMqB,EAAOA,EAAKrB,IAAMhB,EAAKgB,KAI/B7J,EAAQ6M,GAAQhD,EAAIqC,EAAKjN,MAAM+K,YAI3BkC,EAAKlD,QDnUF,QCoUG8C,EAAM9L,MAAQA,YD9TjB,QCgUJ,IACH8L,EAAMI,EAAKlD,IAAMhJ,aAEd2M,EACHG,GAAW5B,EAAMrC,EAAMqD,EAAKrI,OAAOmG,IAAI+C,QAAU/M,YAKlD,eACKkM,EAAK5C,UACN,UACHkC,WAAOlB,GAASwB,aAEb,UACHN,EACElB,GAASwB,KACTe,GAAQC,GAAW5B,EAAMrC,EAAMqD,EAAKjN,MAAM+K,eDlVpC,SC4VZwB,GAAQwB,GAAOjB,EAAOG,EAAMJ,aAEzB,SAECG,IAAUJ,GD1WF,WC0WSvC,EAAiB,CACpCmD,GAASR,EAAOH,ED3WN,mBC4WDH,MAER,UACHD,GAA2B,UAAjB7C,EAAKM,KAAK8D,GACpBnB,EAAM9L,MAAQgN,GAAOjB,EAAOG,EAAMJ,GAClCJ,GAAUD,EAAiBC,QAG/BH,EAAOQ,EAAMC,MAAQR,MAElBD,MACE,IAAIU,EAAQ,EAAGA,EAAQpD,EAAK3B,KAAK5E,OAAQ2J,IAC5Cb,GACE,QACAF,EACArC,EAAK3B,KAAK+E,GACVH,EACAxB,GAASwB,GACTX,GAAYW,IAKpBR,GAASG,EAAiBH,OAC1BV,GAAca,EAAiBb,YAC/BG,GAAWI,GAAYM,IC9XlB,SAASyB,EAAeC,GAAgC,IAAjB9E,EAAiB,iEACzDxH,EAAOwH,EAAS,IAChB+E,EAAQ,GACR/K,EAAI,MAEH,IAAMgL,KAAOF,EAAU,KAEpB3C,EAAO2C,EAASE,MACV,MAAR7C,IACF3J,GAAQuM,EAERvM,GAAQyM,EAAQ9C,GAAQA,EAAK+C,cAAcC,SAAWhD,EAAKiD,YAInD,MAFVpL,GAAK,GAES,MACd+K,EAAQ,YAEVvM,GAAQ,IAuBH,SAAS6M,EAAW7M,EAAckI,OACnC4E,EACAH,EACAI,EACEC,EAAYhN,SACbkI,GAQH6E,EAAY7E,EAAOwE,cACC,IAAhB1M,EAAKyB,QACPqL,EAAOC,EAAUD,KACjBH,EAAWI,EAAUJ,WAErBG,EAAOC,EAAUD,KAAKG,OAAO,CAACjN,IAE5B2M,EADgC,IAA9BI,EAAUJ,SAASlL,OACVzB,EAEK+M,EAAUJ,SAAW,IAAM3M,KAf7C8M,EADkB,IAAhB9M,EAAKyB,OACA,GAEA,CAACzB,GAEV2M,EAAW3M,GAeN,CAACgN,YAAWL,WAAUG,QC5ExB,SAASI,EACdC,EACAC,OAEK,IAAMZ,KAAOW,EAChBC,EAAGD,EAAIX,GAAMA,GAkBV,SAASa,EAAQC,EAAW/K,GACjC+K,EAAKD,QAAQ9K,GC+HR,SAAShE,EACdgP,EACAC,OAEMlP,EAAa,SAAbA,EAAcsL,GAAD,2BAAsB6D,EAAtB,iCAAsBA,EAAtB,yBACb1D,GApBR,SAAoBJ,EAAW+D,EAAe9D,EAAc6D,OACpDE,EAAU5D,GACZM,EAAO,QACPqD,MACFrD,EAAON,GACAM,GAAQA,EAAKqD,WAAaA,GAC/BrD,EAAOuD,GAAUvD,GAGrBwD,GAAexD,OACT1I,EAASgI,EAAKmE,OAAOlE,EAAS6D,UACpCI,GAAeF,GACRhM,EAZT,CAqBwBrD,EAAOoP,EAAU9D,EAAS6D,GAEvCnP,EAAMwP,OAAOlE,EAAS6D,IAE/BnP,EAAMyP,SAAWhG,EAAW,CAC1BO,KAAM0F,GJjKW,QIiKK1P,EAAOkP,EAAaD,GAC1C7E,SAAU,IAGZpK,EAAMwP,OAAU3D,mBAEdT,EADeQ,GAAWA,GAAS+D,KAAK3P,GAASA,EAClC6L,GACRA,GAET7L,EAAM4P,MAAQC,EAAKC,GAAW9P,GAC9BA,EAAMU,IAAOuD,gBACPc,EACArD,EACA2H,EAASpF,KACXc,EAASd,EACTvC,EAAOuC,EAAGvC,KACVuC,EAAKA,EAAGA,QAEJ8L,EAAS9P,EAAY+P,GAAQhQ,EAAO0B,GAAOqD,UACjDkL,GAAkBjQ,EAAO+P,EAAQG,EAAKjM,GAC/B8L,GAET/P,EAAMiC,OAAUgC,mBACdkM,GAAsBnQ,EJ7KJ,SI6KmBiE,EAAGA,GAAKA,EAAKA,EAAGA,GAAI,CACvD8E,EAAY,CAAC9E,GAAImM,QAErBpQ,EAAMqQ,UAAapM,mBACjBkM,GAAsBnQ,EAAO,YAAaiE,EAAI,CAC5C8E,EAAa,CAAC9E,GAAImM,KAClBrH,EAAWuH,aAEftQ,EAAMuQ,QAAWtM,gBACTuM,EAA2BvQ,EAAY,YAASD,EAAM0O,UAAW,CACrE9E,OAAQ0F,GAAUtP,KAEdoP,EAAWqB,YACbrB,GACFlD,GAASsE,GAAc/F,IAAInH,KAAK8L,EAASsB,QAE3CT,GAAkBO,EAAcxQ,EAAO,UAAWiE,GAClD0M,GAAgB3Q,EAAOwQ,GAChBA,OAEHpB,EAAWqB,YACVzQ,EAGF,SAASD,EACd6Q,EACAC,YA8HSC,EAAQ9Q,EAAYiE,GAC3BnE,EAAMiR,IAAI/Q,GACVgR,GAAelR,GAAOkC,IACpBhC,EACAiR,GACEC,GAAYlR,EAAOF,EAAO,KAAM,EAAMmE,EAAIkN,SAjI1CC,EAAaC,GAAeT,GAC5BU,EAAWD,GAAeT,GAC1BW,EAAUC,GAAiB,WAC3BpC,EAAWqB,KACjBW,EAAWK,MAAQ,CAAC,CAACtH,KAAM,OAAQN,GAAIyH,IACnClC,GACFA,EAASsC,MAAMpO,KAAK8N,EAAYE,OAE5BK,EAAeP,EAAWvG,GAC1B/K,EAAa,CACjB8R,YAAa,IAAIC,IACjBN,UACAX,eACAkB,SAAUV,EACVW,SALiB,WAKjBA,IAEMC,EADAC,EAAYb,KAEZ3F,GAAa,CACJA,IADI,IACXM,EAAON,GACJM,IAASA,EAAKrB,IAAIiH,IACvB5F,EAAOuD,GAAUvD,GAEfA,IAAMiG,EAAcjG,UAErBiG,GAAepG,IAAYA,GAASlB,IAAIiH,KAC3CK,EAAcpG,IAEZoG,IAAaC,EAAYD,EAAYtH,IAAIiH,IACtCjE,GAAQuE,IAEjBC,SArBiB,SAqBRC,OACHzN,EACAkH,KACFlH,EAASkH,GAASwG,QAAQlG,GAASpM,GAAO+K,KAEvCnG,IAAQA,EAAS5E,GACtBsL,EAAO,CACL1G,SACAmH,OAAQsG,EACRrG,MAAO,KAGXvK,MAjCiB,WAiCRhB,sFACYA,EADZA,gBACF,IAAM8K,OAAevL,EAAMoE,GAAGmH,GAAM,kBAAMvL,EAAM8Q,uBAC9C9Q,GAEToE,GArCiB,SAqCdmO,EAAcpO,MACfuF,EAAc6I,EAAS,MAAO,kBAC1BlL,MAAMC,QAAQiL,GAFHpO,WAGOoO,GAHPpO,IAEGoO,4BAEdvB,EAFcuB,QAECpO,IAJJA,oCAOb6M,EAAQuB,EAASpO,UAEZnE,GAETiR,IAhDiB,SAgDb1F,OACIiH,EAAsBtB,GAAelR,GAAOyS,IAAIlH,UAClDiH,IACFA,IACAtB,GAAelR,GAAOyN,OAAOlC,IAExBvL,GAETY,IAxDiB,SAwDbuD,EAASuO,OACPzN,EACArD,EAOA+Q,EANApJ,EAASpF,KACXc,EAASd,EACTvC,EAAOuC,EAAGvC,KACV8Q,EAAavO,EAAGuO,WAChBvO,EAAKA,EAAGA,QAGJyO,EAAa5S,EAAMiS,WACnB3C,EAAWqB,KACbrB,EACFqD,EAAa,cACJC,IACTD,EAAaxO,EAAGyO,EAAYF,QAGxBG,EAAyB5S,EAAY0S,EAAY,CACrD/Q,KAAMsO,GAAQlQ,EAAO4B,GACrBqD,SACA6N,OAAQ,IAEJC,EAAW3B,GAAYpR,EAAO6S,EAAYzC,EAAK,EAAOjM,UAE5D6O,GAAcH,GAAYI,OAAS,CACjC,CACE5I,KAAM+F,EACNjM,KACA0F,KAAMyH,IAGNhC,IACG1L,GAAS0L,EAASsC,MAAON,IACvB1N,GAASmP,EAASpI,IAAK2E,EAAS4D,SACnCH,EAASpI,IAAIwI,QAAQ7D,EAAS4D,SAI7BL,GAET/C,MAjGiB,SAiGXsD,EAAgBjP,OACfA,IAAOkK,EAAQ+E,GAAY,KACxBC,EAAerD,GAAUhQ,EAAOoT,GAChC9D,EAAWqB,YACbrB,EACFA,EAASQ,MAAMtM,KAAK,CAClB8P,GAAIhC,EACJnN,GAAIiP,IAGNA,EAAUpT,EAAMiS,YAEXoB,SAEJ7J,EAAWrF,IAAKsF,EAAW,wCACzB2J,EAAUtD,OAAOtE,mBAAiBrH,EAAGnE,EAAMiS,WAAYzG,QAY5DtB,EAAO0F,GAASlC,EAAO1N,EAAO+Q,GAC9BM,EAAerR,EAAMuT,cAAclC,oBACzCrR,EAAM2P,SAAWhG,EAAW,CAC1BM,MAAO,CAACoI,MAAOf,GACf1H,KAAM,CACJX,EAAWuH,UACXvH,EAAW7H,QAAQ,CACjBpB,MAAOwR,IAETH,GAAgBpI,EAAS,CAACjJ,MAAOwR,EAAUzH,GJtV5B,MIuVfsH,GACEpI,EAAY,CACV9E,GAAI,SAACqP,EAAQnP,EAAT,OAAaoP,EAAb,EAAaA,EAAb,OAAoBpC,EAAamC,EAAQC,MAEjDxK,GAAY,CACVjJ,MAAOsR,IAETrI,GAAY,CACVjJ,MAAOwR,KAGXxH,MAAOyH,EACPvH,OACAI,SAAU,IAERoJ,aAAY5C,GACdrH,EAAW,sDACb2B,GAAIpL,EAAO,CAACyR,IACLzR,ECxWF,SAAS8B,IAAWuN,4EACrBsE,EACAC,EACA3O,EACJ4O,GAAgBxE,EAAK,IAAI,SAACyE,EAAcC,GACtC9O,EAAS6O,EACTzE,EAAO0E,SAULC,EACAC,EATEC,EAAa7E,EAAKA,EAAKhM,OAAS,MAClCmG,EAAW0K,IACbN,EAASvE,EAAK8E,MAAM,GAAI,GACxBR,EAAUO,GAEVN,EAASvE,EAKW,IAAlBuE,EAAOvQ,OAAc,KACjB0L,EAAM6E,EAAO,GAIdvF,EAASU,KAcZiF,EAAmBjF,EACnBkF,EAAa,UAGZA,IAIHD,EAAmBJ,EAKfD,IACFA,EAAUS,GAAWT,KAGpBpK,EAASyK,IAAmBvK,EAAW,6BACrC4K,GACLhN,MAAMC,QAAQ0M,GACdA,EACA/O,EACA0O,GCzEG,SAASW,QAKR/Q,EAAS,UAKfA,EAAOgR,IAAM,IAAIC,SAAQ,SAACC,EAAIC,GAC5BnR,EAAOkR,GAAKA,EACZlR,EAAOmR,GAAKA,KAEdnR,EAAOgR,IAAII,OAAMxM,eACV5E,ECJF,SAASqR,EACdzF,EACAC,OAEMyF,EAAgB1U,EAAYgP,EAAcC,GAC5CuE,EACFkB,EAAStB,cAAcI,2BAChBlK,+BAAiCoL,EAASC,aAC7ClL,EAAOwC,GAASyI,GACtBjL,EAAKM,KAAK6K,OAAS,CAAC,UACpBnL,EAAKM,KAAKqB,KAAOsJ,EAASG,KPnBN,SOoBpBH,EAASI,IAAO9Q,mBACTqF,EAAWrF,IAAKsF,EAAW,sCAChCkK,EAAUxP,EACH0Q,OAEHK,EAAUL,EAASM,QAAUzD,GAAiB,WAC9CxJ,EAAQ2M,EAAS3M,KAAQgN,EAAe3E,UAAU,CACtD6E,MAAO,OACPjR,GAFsD,YAElCZ,IAAhB8R,EAAgB9R,EAAjB8R,OAAStJ,EAAQxI,EAAjB8R,OAAiB9R,IAAjB8R,OAAiB9R,GACH,SAAX8R,EAAmB,MAAO,CAACtJ,SAAQxI,aAGrCwJ,EAAQ8H,EAAS9H,KAAQmI,EAAe3E,UAAU,CACtD6E,MAAO,OACPjR,GAFsD,YAElCyB,IAAhByP,EAAgBzP,EAAjByP,OAAStJ,EAAQnG,EAAjByP,OAAiBzP,IAAjByP,MAAiBzP,GACH,SAAXyP,EAAmB,MAAO,CAACtJ,SAAQnG,YAGrC0P,EAAYT,EAASS,SAAWpN,EAAKtH,IAAI,CAC7CwU,MAAO,WACPjR,GAAI,qBAAEZ,UAEFgS,EAAYV,EAASU,SAAWxI,EAAKnM,IAAI,CAC7CwU,MAAO,WACPjR,GAAI,qBAAEyB,SAGF4P,EAAe7L,EAAW,CAC9BM,MAAO,CACLwL,WAAYZ,EAASI,IAAIS,WAAa,kBAAM/B,GAC5CwB,QAASD,GAEXtL,KAAM,CACJX,EAAS,CACP9E,GADO,aAC0C0I,OAe3CtJ,EAfFwI,EAA6Cc,EAA9Cd,OAASwI,EAAqC1H,EAA9Cd,IAAyBmJ,EAAqBrI,EAA9BsI,QAAiBM,EAAa5I,EAA/B4I,WACVE,EAAYC,GAAU,CAC1B7J,SACAwI,MACAsB,GAAI,EACJX,SACArI,UAEIiJ,EAAWF,GAAU,CACzB7J,SACAwI,MACAsB,GAAI,EACJX,SACArI,cAIAtJ,EAASkS,IAAa1J,GACtB,MAAO5D,eACK2N,EAAS3N,GAEnBoB,EAAShG,IAAWiG,EAAWjG,EAAOwS,MACxCxS,EAAOwS,KAAKJ,EAAWG,GAEvBH,EAAUpS,OAKlB2G,KAAM,CACJ8D,GAAI,KACJgI,GAAI,SACJjB,OAAQ,CAAC,cAGbnL,EAAKK,MAAMgM,OAAST,EACpB5L,EAAKe,IAAInH,KACPyF,EAAa,CACX9E,GAAE,SAAC4H,EAAQ9B,EAAO4C,GAAhB,OAEK2C,GAAU3C,GACR,CACLd,SACAwI,IAAK,CACHE,GADG,SACAxH,KACHyH,GAFG,SAEAzH,OALuBlB,KAUlC9C,EAAS,CACP9E,GAAE,SAAC+R,EAAD,EAAgBrJ,GAAhB,OACAvB,EAAO,CACL1G,OAFF,EAAMqR,OAGJlK,OAAQmK,EACRlK,MAAO,EACPF,SAAUI,GAAYW,KAEjBqJ,EAAInK,WAIjB8I,EAASnF,OAAU3D,gBACXwI,EAAMD,IACN9I,EAAU,CAACO,SAAQwI,UACrBzI,GAAU,KACPW,GAAS,KACN0J,EAAYrK,GAClByI,EAAIA,IACDY,SAAQ,WACPiB,GAAYD,MAEbxB,OAAM,eAEXrJ,EAAOQ,GAAS+D,KAAKgF,GAAWrJ,QAEhCF,EAAOuJ,EAAUrJ,UAEZ+I,EAAIA,SAGP8B,EAAYxB,EAASwB,SAAWpW,EAAY,EAAG,CAACmV,MAAO,aAC1DhR,GAAGyQ,GAAUyB,mBAAKA,EAAI,KACtBlS,GAAG8Q,GAAQoB,mBAAKA,EAAI,KAEjBC,EAAW1B,EAAS0B,QAAUF,EAASzV,IAAI,CAE/CuD,GAAIqS,mBAAUA,EAAS,GACvBpB,MAAO,mBAGThK,GAAIyJ,EAAU,CACZK,EACAhN,EACA6E,EACAuI,EACAC,EACAgB,EACAF,EACAb,IAEKX,ECvJF,SAAS5Q,EACdwS,EACAxR,OAEM1B,EAASpD,EAAY8E,GAAUgJ,EAAewI,EAAQ,iBAC5D/M,EAAc+M,EAAQ,QAAS,kBAC/BC,GAAQ,CACN7M,KAAM4M,EACN1M,GAAIxG,EACJ2G,KAAM,CAAC8D,GAAI,WAENzK,ECgBF,SAASO,IAAUuL,wEACpBzK,MACAhD,EAEA+U,EACAC,EAJAhS,EAEkCiS,GAAoBxH,GAFtDzK,qBAEE3B,EAFF2B,KAEUZ,EAFVY,KAEiBT,EAFjBS,KAEsBkS,EAFtBlS,UAEsDyK,IAItDrL,GAAuBuF,EAAStG,IApBRgC,gBACxB8R,EAAwB,SAC5B9H,EAAQ+H,IAAoBpU,YACtBA,KAASqC,IACU,MAAjBA,EAAOrC,IACT6G,oBAAsB7G,EAAtB6G,uBAEFsN,EAAwB,MAGrBA,EAVqB9R,CAoBwChC,KAClEe,EAAQf,EAAOe,MACfG,EAAKlB,EAAOkB,GACZyS,EAAS3T,EAAO2T,OAEhBhS,EAAS3B,EAAO2B,OAChBhD,EAAOqB,EAAOrB,KACd+U,EAAM1T,EAAO0T,IACb1T,EAASA,EAAOA,YAEdgU,EAAgB,WAChBhU,IACFyG,EAAc1F,EAAO,SAAU,SAC3BqD,MAAMC,QAAQtD,KAChBA,EAAQC,EAAMD,IAEhBf,EAASe,EACTiT,EAAgB,GAEdA,IAAkB5I,EAAQpL,KAC5BA,EAASnB,EAAQmB,aAEfe,IAEFA,EAAQf,GAEVyG,EAAc1F,EAAO,SAAU,SAC/BpC,EAAOkV,GAAYlV,GAAQqB,EAAO2L,cAC5BU,EAAWqB,KACXuG,IAAatS,EACdA,IACCyJ,EAASpL,IAAWoL,EAASrK,GAI/BY,EAAS3E,EAHYkE,EACjBA,EAAGyJ,GAAQoF,GAAc/P,IAAU2K,GAAQoF,GAAchP,KACzD4J,GAAQoF,GAAc/P,IACS,CAACrB,OAAM+U,SAE1C/R,EAASzE,EAAYyB,GACjB0N,GACFlD,GAASxH,GAAQ+F,IAAInH,KAAK8L,EAAS4D,cAInCiE,EACJD,GAAY7I,EAAQzJ,IAAWwH,GAASxH,GAAQsF,KAAKkN,kBACnD/I,EAASpL,GAAS,KACdoU,EAAYrE,GAAc/P,GAChCmI,GAAInI,EAAQ,CACVqU,GAAetT,EAAOY,EAAQ,CAC5BqF,MAAO,CAAC9F,KAAIgT,kBACZvN,KAAM,CACJ0F,GAAYA,EAAS4D,QAEpB0D,GAAU3N,EAAa,CAACmE,STzFZ,YS0FbnE,EAAS,CACPjJ,MAAOqX,EACPtN,GAAI5F,ETnFK,IANA,US2FXA,GAAM8E,EAAa,CAAC9E,GAAIoT,KACxBjI,GAAY4H,GAAY5H,EAASsB,QAEnC1G,KAAM,CAAC8D,GT1FO,SS0FKlK,OAAQ4J,OAG3B4B,IAEC1L,GAAS0L,EAASsC,MAAOyF,IACzBzT,GAAS0L,EAASkI,QAASH,IAE5B/H,EAASkI,QAAQhU,KAAK6T,QAGrB,KACCI,EAAYlG,GAAe,GAC3BmG,EAAcnG,KACdoG,EAAapG,KACfjC,GACFA,EAASsC,MAAMpO,KAAKiU,EAAWC,EAAaC,GAE9ChO,EAAW,CACTG,OAAQ7G,EACR2G,KAAM,CACJX,GAAY,CAACjJ,MAAO0X,IACpBzO,EAAS,CACPY,KTnHW,QSoHX7J,MAAO,EACP4E,OAAQ6S,KAGZtN,OAAQ,CACNO,OAAQ,CAACzH,EAAQ2B,EAAQZ,GACzByG,MAAO7F,GAETsF,KAAM,CAAC8D,GT1HS,SS0HGlK,OAAQ,UAC3BwG,SAAU,IAEZc,GAAInI,EAAQ,CACVqU,GAAetT,EAAOY,EAAQ,CAC5BqF,MAAO,CACL9F,KACAgT,kBAEFvN,KAAM,CACJ0F,GAAYA,EAAS4D,OACrBjK,GAAY,CAACjJ,MAAO2X,IACpB1O,EAAS,CAACjJ,MAAOyX,IACjBxO,EAAY,CAAC9E,GAAIsT,mBAAaA,MAE7Bb,GAAU3N,EAAa,CAACmE,SThJZ,YSiJbnE,EAAS,CAACjJ,MAAO0X,IACjBzO,EAAS,CACPjJ,MAAO2X,EACP5N,GT3IS,MS6IX5F,GAAM8E,EAAa,CAAC9E,GAAIyT,KACxBtI,GAAY4H,GAAY5H,EAASsB,QAEnC1G,KAAM,CAAC8D,GTlJO,SSkJKlK,OAAQ,oBAI1Bc,ECrJF,SAASD,IAAS0K,wEACjBnF,MAA4B,CAAC8D,GAAI,SACnC6J,EAAU,QADR3N,EAE6B2M,GAAoBxH,GAFjDnF,qBAEAjH,EAFAiH,KAEQjF,EAFRiF,KAEiB4M,EAFjB5M,KAGF4M,IACF5M,EAAKjF,OAAS6R,EACVA,EAASlV,OAAMiW,EAAUf,EAASlV,OAEnCqD,IAEHhC,GADAgC,EAAShC,GACOA,QAVKoM,MAYuBpK,EAAzC9C,EAZkBkN,EAULpM,OAEL2T,EAZUvH,EAYnBuH,OAAiB5S,EAZEqL,EAYnBuH,MAZmBvH,IAYnBuH,KAAwBhV,OAZLyN,MAYYwI,EAZZxI,EAajBzK,EAASK,EAAOL,QAAUzE,EAAYyB,EAAMsI,EAAKjF,QACjD6S,EAAezJ,EAAQlM,GACzB8U,EAAgB,kBAChBhU,IACFyG,EAAc1F,EAAO,QAAS,SAC1BqD,MAAMC,QAAQtD,KAChBA,EAAQC,EAAMD,IAEhBf,EAASe,EACTiT,EAAgB,GAEdA,IAAkB5I,EAAQpL,KAASA,EAASnB,EAAQmB,IACpDe,IACF0F,EAAc1F,EAAO,QAAS,SAC9Bf,EAASa,EAAO,CACdb,SACAe,QACA4S,SACAzS,GAAI2T,EAAe,KAAO,SAAC7U,EAAae,GAAd,MAAcA,CAAiBf,SAAQe,aAGrE0F,EAAc9E,EAAQ,QAAS,UAC3BkT,EACFhU,EAAO,CACLb,OAAQd,EACR6B,MAAOf,EACP2B,OAAQ+E,EAAW,CACjBC,KAAM,CACJX,EAAY,CACV9E,GAAI,qBAAEQ,SAERsE,EAAa,CACX9E,GAAI,qBAAE8I,SAGVjD,MAAOpF,EACPsF,OACAC,OAAQ,CACNO,QAASzH,EAAQd,EAAQyC,GAAzB8F,mBAAoC,GAAGmE,OAAO7K,GAAgB,MAC9DyG,MAAO7F,GAET0F,SAAU,IAEZnG,GAAI,SAACQ,EAAYsI,GAAb,MAAaA,CAAgBtI,QAAOsI,SACxC2J,SACAhV,UAGG4H,EAAWrH,IAASsH,EAAW,uCACpC6N,GAAerU,EAAQ2B,EAAQ,CAC7BqF,MAAO,CAAC9F,GAAIhC,GACZyH,KAAM5F,EACF,CACEiF,EAAY,CACV9E,GAAI,kBAAElB,EAAF,EAAEA,OAAQe,EAAV,EAAUA,MAAV,OAA2BG,EAA3B,EAAmBA,IAAWlB,EAAQe,MAE5CiF,EAAa,CACX9E,GAAI,qBAAElB,WAGV,CAACgG,EAAY,CAAC9E,GAAImM,MACtBpG,UAGGtF,ECpFF,SAASmT,EAAQhJ,EAAU+B,EAAmB7L,MAC/CoJ,EAASU,UACJA,KAELV,EAAQU,GAAM,KAEZxL,EADExD,EAASyP,GAAUT,UAErBV,EAASU,KACXxL,EAAStD,EAAY6Q,EAAc,CACjChH,OAAQ/J,EACR6B,KAAMmN,EAAIH,UACVoJ,SAAG/S,IACFb,GAAG2K,GAAK,SAAC1K,EAAG4T,GAAJ,OAAUA,MAEnB5J,EAAUU,KACZxL,EAAStD,EAAY6Q,EAAc,CACjChH,OAAQ/J,EACR6B,KAAMmN,EAAIH,UACVoJ,SAAG/S,IACFb,GAAG2K,EAAI7G,MAAM,SAAC7D,EAAD,YAAUd,WAExBxD,GAAQA,EAAOmY,MAAMlY,MAAMuD,GACxBA,MAEHA,EAA8B8D,MAAMC,QAAQyH,GAAO,GAAK,UAC9DD,EAAMC,GAAK,SAAChO,EAAOqN,GACjB7K,EAAO6K,GAAOC,EAAStN,GAASA,EAAQd,EAAYc,EAAO,CAACa,KAAMwM,OAE7D7K,EV2DT,IW5FO,IAAM4U,EACQ,oBAAX5Q,QAA0BA,OAAO6Q,YAAe,eZD7C1K,EAAQ,QAER2K,EAAS,SAITjI,EAAM,MaFN7E,EAAQwD,mBAClBvF,EAAWuF,IAAQxF,EAASwF,KAAS,SAAUA,GAE5CV,EAAMhE,mBAAgB0E,mBAAaxD,EAAKwD,IAAQA,EAAIiG,OAAS3K,IAEtDrK,EAAQqO,EAAGX,GACXxN,EAAQmO,EbTA,SaURiK,EAASjK,EAAGgK,GACZtY,EAASsO,EbTA,sEcHT5E,EAAc8O,kBACnBC,MAAMD,IhBGDhP,EAAYxI,kBACN,iBAAVA,GAAgC,OAAVA,GAClByI,EAAczI,kBAAgC,mBAAVA,GAEpC0X,EAAgB1X,YACtBwI,EAASxI,IAAWyI,EAAWzI,IAClC0I,EAAW,uCiBVTiP,EAAU,eACV3N,EAAK,SACF,oBAASA,GAAIyD,SAAS,MAGlBmK,EAAaD,IACbE,EAAaF,IACb1N,EAAa0N,ICPb3I,EAAO,SAAC5L,EAAcS,GAAf,OAA+BT,EAAG4L,KAAK,KAAMnL,IACpDiU,EAAQ,SAAC1U,EAAcS,EAAakU,GAA5B,OACnB3U,EAAG4L,KAAK,KAAMnL,EAAQkU,ICGlBC,EAAM,SAAC1O,EAAW2O,EAAiB/L,GAA7B,MAA6BA,CACvClC,GAAI6N,IACJvO,OACA4C,OACA+L,WAGEC,EAAgB,EAEPC,EAAiE,SAAC,GAAD,QAC5E9L,SAD4E,OAG5E2L,EjBTqB,UiBSR,EAAO,CAClB7L,YAAa+L,EACb7L,cAL0E,MjBNvD,UiBMuD,KAOjE+L,EAKD,SAAC,GAAD,QAAEtP,YAAF,MAAS6D,EAAT,EAAgB1N,EAAhB,EAAgBA,MAAO4E,EAAvB,EAAuBA,OAAvB,IAA+BmF,GAA/B,OACVgP,EAAI,MAAOlP,IAAS6D,EAAO,CAAC7D,OAAM7J,QAAO+J,QAD/B,MAAoCnF,EAAS8I,EjBnBpC,QiBmBT,EACmC9I,YAClCwU,EAGT,CACF5I,QAAS,kBAAMuI,EAAI,QAAS,EAAO,CAAC1O,KAAM,aAC1CjJ,QAAS,gBAAEpB,EAAF,EAAEA,MAAF,OAAa+Y,EAAI,QAAS,EAAM,CAAC1O,KAAM,UAAWrK,YAEhDqZ,EAEGR,EAAME,EAAK,UAAW,GACzB5W,EAEE0W,EAAME,EjB5BC,SiB4BY,GACrBO,EAEDT,EAAME,EAAK,MAAO,GACjBvF,GAA2C,SAAC,GAAD,IAAExT,EAAF,EAAEA,MAAF,OACtDmZ,EAAI,CAACtP,KjBtCc,QiBsCDjF,OAAQ5E,KC1CfuR,GAAkBzD,mBAC7B/C,GAAI6N,IACJ9K,YAEWF,GAAU,SAAC,GAAD,SAAEE,SCPZ8J,GAAgB,SAAC/K,EAAD,YAAqC1I,EAArC,EAAcA,IAA0B0I,EAAxC,EAAyB4G,IACzC8D,GAAgB,SAAC1K,EAAD,YAAqC1I,EAArC,EAAcA,IAAd,EAAyBsP,EAAkB5G,IAC3DyD,GAAY,SAACzD,EAAD,UAAmC1I,EAAnC,EAAcA,IAAwB0I,ICAlDT,GAAYmN,mBAAqBA,EAAM5J,UAAY4J,GACnDtO,GAAarB,mBAAeA,EAAKO,OAAOO,QACxCQ,GAAYtB,mBAAeA,EAAKO,OAAOM,OACvCuI,GAAiBhT,mBAAyBA,EAAMgS,UAChDwH,GAAaC,mBAAcA,EAAKxU,QAChCyU,GAAmBD,mBAAcA,EAAKzB,QACtC3M,GAAYwB,mBAAeA,EAAM9L,OACjCmQ,GAAkBlR,mBAAeA,EAAM8R,aACvCtC,GAAajE,mBAAcA,EAAKzB,QAChCoC,GAAeyN,mBAAaA,EAAI7N,UCPhCV,GAAM,SAACwO,EAAqBnP,GAChBmP,IADgBnP,IACjCoP,EAAQzN,GAASwN,GACdxW,EAAI,EAAGA,EAAIqH,EAAMpH,OAAQD,IAAK,KAC/B0W,EAAO1N,GAAS3B,EAAMrH,IrBJV,WqBKdyW,EAAM1P,OAAOE,OAAiByP,EAAK3P,OAAOE,KrBHzB,aqBIrBY,GAAU6O,GAAMtW,KAAKqW,GACrB3O,GAAS2O,GAAOrW,KAAKsW,KCCd3O,GAAkC,KAEhCwF,GAAe,kBAAMxF,IAAeA,GAAYmE,UAChDyK,GAAepD,mBACtBA,GAAOxL,IAAeA,GAAY6O,UACpCrD,YAASxL,GAAY6O,QAArBrD,iBAAgCA,IAC3BA,GvBVHnM,GAAc,WAC8B,IAAhD0E,EAAgD,0DAE1C3L,EAAS,MACX8D,MAAMC,QAAQ4H,OACX,IAAI9L,EAAI,EAAGA,EAAI8L,EAAK7L,OAAQD,IAC3BiE,MAAMC,QAAQ4H,EAAK9L,IAAKG,EAAOC,KAAPD,oBAAgB2L,EAAK9L,KAC5CG,EAAOC,KAAK0L,EAAK9L,SAGxBG,EAAOC,KAAK0L,UAEP3L,EAAO3C,IAAIwL,KAEPtB,GAAW,SAAC,EAEvBF,OAEI5K,EAHHgZ,EACDpO,EADCoO,OAAQ3O,EACTO,EADSP,KAAM4C,EACfrC,EADeqC,KAIX+L,IAEFpO,GADA5K,EAAQiN,EAAKjN,OACH+K,IAAM/K,GAEL,QAATqK,GAAkB4C,EAAKlD,KAAO2D,IAEhC9C,GADA5K,EAAQiN,EAAKrI,QACHmG,IAAM/K,IE6BhBia,GAAyB,KAEvBhW,GAAQ,SAARA,EAASwP,EAAqByG,OAC7BzG,EAAG,OAAOyG,MACVA,EAAG,OAAOzG,MAEX0G,EACEC,EAAa3G,EAAEwE,EAAE5N,OAAS6P,EAAEjC,EAAE5N,YAMjC+P,GAAc3G,EAAEwE,EAAElN,GAAKmP,EAAEjC,EAAElN,KAE1BqP,GDxEiB,YCwEH3G,EAAEwE,EAAE5N,QAEpB8P,EAAM1G,EACNA,EAAIyG,EACJA,EAAIC,GAENA,EAAMlW,EAAMwP,EAAE4G,EAAGH,GACjBzG,EAAE4G,EAAI5G,EAAE6G,EACR7G,EAAE6G,EAAIH,EAEC1G,GAIH8G,GAAuB,GACzBC,GAAK,EACFA,GAAK,GAKVD,GAAM/W,KAAK,CAACiX,MAAO,KAAMC,KAAM,KAAMC,KAAM,IAC3CH,IAAM,EAGR,IAmGW1O,GG5IP4H,GHyCE/G,GAAY,eACX,IAAIvJ,EAAI,EAAGA,EAAI,EAAGA,IAAK,KACpB8L,EAAOqL,GAAMnX,MACf8L,EAAKyL,KAAO,EAAG,IAKP,IAANvX,GAAiB,IAANA,EAAS,CACtB8L,EAAKyL,MAAQ,MACP5Z,EAAQkZ,GAAMhC,SACpBgC,GAAOhW,GAAMgW,GAAMK,EAAGL,GAAMI,GACrBtZ,EAES,IAAdmO,EAAKyL,OACPzL,EAAKwL,KAAO,UAER7P,EAAOqE,EAAKuL,aAClBvL,EAAKuL,MAAQ5P,EAAMwP,EACnBnL,EAAKyL,MAAQ,EACN9P,EAAMoN,KAIb9L,GAAoB,SACxB9B,EACA4B,EACArC,EACAE,EACA/I,EACA+K,GANwB,OAQxB0B,GACE,EACA,CACEiG,EAAG,KACHyG,EAAG,KACHtQ,OACAE,SACA/I,QACAkL,OACAH,YAEFzB,IAEEmD,GAAW,SAACZ,EAAaC,EAAcxC,GAAwB,IAALU,EAAK,yDAC7DqC,EAAWwN,GAAYvQ,GACvBwQ,EAAsBN,GAAMnN,GAC5BvC,EAAkB,CACtBoN,EAAG,CACDrL,MACAC,QACAxC,OACAU,MAGFuP,EAAG,EAEHD,EAAG,GAMY,IAAbjN,GAA+B,IAAbA,EACpB6M,GAAOhW,GAAMgW,GAAMpP,IAEC,IAAhBgQ,EAAOF,KACTE,EAAOJ,MAAQ5P,EAEfgQ,EAAOH,KAAML,EAAIxP,EAEnBgQ,EAAOH,KAAO7P,GAEhBgQ,EAAOF,MAAQ,GAGXC,GAAeE,mBACXA,OACD,eACI,MACJ,cACI,MD/KU,iBCiLV,MDrLU,iBCuLV,OACJzC,SACI,iBAEC,IAIRhL,GAAW,IAAI0N,IAEjB1O,GAAS,EACFI,GAAU,EACVd,GAAmB,KAEjByK,GAAe4E,YAC1BlP,GAAWkP,GAEAvL,GAAkBwL,YAC7BtP,GAAcsP,GAGVtN,GAAgB,SAAC1B,EAAWlB,MAC5BkB,EAAM,MACDA,IAASA,EAAKrB,IAAIG,IACvBkB,EAAOuD,GAAUvD,MAEfA,EAAM,OAAOA,SAEZ,MAEH4B,GAAa,SAAC5B,EAAWrC,EAAYmB,GAAxB,OACE4C,GAAc1B,EAAMlB,IACLnB,GAAMgB,IAAIG,IAgLxCgD,GAAS,SAACjB,EAAD,EAA0BD,OAAV1I,EAAU0I,EAAV1I,GAAU0I,WAE9B1I,EAAGkH,GAASwB,GAAQC,EAAM7C,MAAO4C,GACxC,MAAO1E,GACP+S,QAAQtV,MAAMuC,GACd2E,EAAMC,KAAO,IC5YJoO,GAAW,SAAC5P,EAAW6P,GAAZ,MAA4B,GAAK7P,EAAKqD,UAAYwM,GAE7DlL,GAAU,SAAC3E,EAAW3J,GAAZ,OACb,MAARA,EAAeuZ,GAAS5P,EAAM,aAAU3J,GqBJ7BiS,GAAkB,SAC7BwH,EACAlX,GAEAsU,EAAa4C,GACT3B,GAAgB2B,IAClBlX,EAAGqV,GAAU6B,GAAY3B,GAAgB2B,KAIhCxE,GAAuBxH,gBAC9ByH,SACJjD,GAAgBxE,EAAK,IAAI,SAACiM,EAAUrW,GAClC6R,EAAWwE,EACXjM,EAAOpK,KAEF,CAACoK,EAAMyH,IpBVHlT,GAAW,SAACsL,EAAarE,GAAd,OAA4BqE,EAAKtL,SAASiH,IAErD0Q,GAAa,SAACrM,EAAarE,OAChC2Q,EAAMtM,EAAKuM,QAAQ5Q,IACZ,IAAT2Q,GACFtM,EAAKwM,OAAOF,EAAK,IqBRfG,GAAiB,SAACC,EAAmBC,GACzCN,GAAWK,EAAY3T,KAAM4T,GAC7BN,GAAWtQ,GAAU2Q,GAAcC,GACnCN,GAAWrQ,GAAS0Q,GAAcC,IAE9BC,GAAsB,SAAtBA,EACJD,EACAE,EACAC,OAMIJ,EAJJC,EAAW5T,KAAK5E,OAAS,EACzBwY,EAAWlR,IAAItH,OAAS,EAExBwY,EAAW5R,MAAQ,KAEC4R,IAFD,IAEf3M,EAAOhE,GAAS2Q,GACZD,EAAc1M,EAAK+M,OACzBN,GAAeC,EAAaC,IAE1BE,GACCC,IAAiBH,EAAW3R,KAAKpG,QxBrBf,cwBsBnB8X,EAAYzR,OAAOE,OAEnByR,EACEF,EACAG,EACwB,OAAxBH,EAAY1R,KAAK8D,IAAegO,OAItC9M,EAAOjE,GAAU4Q,GACTD,EAAc1M,EAAK+M,OACzBN,GAAeC,EAAaC,GACxBG,GxBlCiB,cwBkCDJ,EAAYzR,OAAOE,MACrCyR,EACEF,EACAG,EACwB,OAAxBH,EAAY1R,KAAK8D,IAAegO,IAKlCE,GAAYtb,mBAAaA,EAAIub,SACtBC,GAAY,SACvBzM,GAKI,gEAHFoM,EAGE,EAHFA,KAKEC,EAAe,KAEfrM,EAAS0M,UAAU1M,EAAS0M,SAAS5O,OAAOkC,GAC5CtB,EAASsB,GACXuM,GAAShL,GAAevB,SACnB,GAAItB,EAAUsB,GAAW,CAC9BqM,EAAe,MAETM,EAAU3M,EAAS2M,QACzBJ,GAASI,EAAQ7F,QACjByF,GAASI,EAAQC,SACjBL,GAASI,EAAQ1I,QACjBsI,GAASI,EAAQE,SAEnBV,GAAoB1P,GAASuD,KAAaoM,EAAMC,ICnErC7K,GAAsBvH,gBAC3BrG,EAASsV,EAAMuD,GAAWxS,UAAM9B,OACtCvE,EAAOkZ,YAAclZ,EACdA,GCDI+T,GAAiB,SAC5BxN,EACAE,EAF4B,UAa5BL,EAAW,CACTC,KAd0B,EAI1BA,KAWAE,SACAE,QACAC,MAjB0B,EAK1BA,MAaAC,KAlB0B,EAM1BA,KAaAC,OAAQ,CACNO,OAAQ,CAACZ,EAAQE,GACjBS,MAAOT,GAETM,SAAU,KAEDoM,GAAW+C,gBAKlBxU,EACJ4O,GAAgB4F,GAAM,SAAC3F,EAAcC,GACnC9O,EAAS6O,EACT2F,EAAO1F,KARa0F,MAUqBA,EAApC5P,EAVe4P,EAUhB5P,KAAOE,EAVS0P,EAUhB5P,GAVgB4P,IAUhB5P,KAAWK,OAVKuP,MAUE,CAACzL,GAAI,WAVPyL,EAUqBA,OAC3C/P,EAAcG,EAAM,UAAW,UAC/BH,EAAcK,EAAI,UAAW,QACzB9E,IAAQiF,EAAKjF,OAASA,GACnBkM,GACLxH,EAAW,CACTG,OAAQD,EACRG,MAAOD,EACPG,OACAC,OAAQ,GACRG,SAAU,MCzCH0F,GAAY,SACvBzE,EACAoI,MAEKnK,EAAWmK,IAAUlK,EAAW,wCACjCqC,GAAU,KACN4Q,EAAa5Q,GAASwG,QAAQlG,GAASb,GAAMR,IAC/C2R,IAAYnR,EAAOmR,UAElBvL,GACLxH,EAAW,CACTM,MAAO,CAAC9F,GAAIwP,GACZ/J,KAAM,CAACX,EAAS,CAAC9E,GAAImM,MACrBxG,OAAQyB,EACRrB,KAAM,CAAC8D,GAAI,SACX7D,OAAQ,CACNO,OAAQa,GAEVjB,SAAU,MvBIVqS,GAAkB,SAAlBA,EAAmBC,EAAW3X,GAAZ,OAClBsE,EAASqT,KACXD,EAAgBnD,GAAUoD,GAAO3X,GAChB,MAAb2X,EAAKhb,OACH2H,EAASqT,EAAKhb,MAAO+a,EAAgBC,EAAKhb,KAAMqD,GAC3CuE,EAAWoT,EAAKhb,MAAOqD,EAAO0O,QAAUiJ,EAAKhb,KACjDqD,EAAOrD,KAAOgb,EAAKhb,MAEtBgb,EAAKC,MAAK5X,EAAO4X,IAAMD,EAAKC,MAC5BD,EAAKjG,KAAoB,OAAbiG,EAAKjG,OAAc1R,EAAO0R,IAAMiG,EAAKjG,KACjDiG,EAAKjJ,UAAS1O,EAAO0O,QAAUiJ,EAAKjJ,SACpCiJ,EAAKvL,eAAcpM,EAAOoM,aAAeuL,EAAKvL,cAC9C7B,GAAUoN,KAAO3X,EAAO6E,OAAS0F,GAAUoN,IAC3C,WAAYA,IAAM3X,EAAO6N,OAAS8J,EAAK9J,QACvC8J,EAAKxH,QAAOnQ,EAAOmQ,MAAQwH,EAAKxH,OACpCuH,EAAgBjD,GAAgBkD,GAAO3X,IAElCA,GAGI4L,GAAkB,SAC7B5N,EACA2B,GJrDmB,IIsDnBkY,EJtDmB,+DIwDftN,GAAUvM,IAASuM,GAAUvM,GAAQiV,MAAM4E,GAAUlY,IAI9CgL,GAAW,SACtBoF,EACAzJ,EACAwR,EACAC,GAEM/X,MAAS0X,GACb,CACE/a,KAAMob,EACN/X,OAAQ8X,GAEV,IAEIE,EJvEc,WIuEHjI,EACXjK,EAAK4N,IARL1T,EASyDA,EAA3D6E,OAACA,OATC7E,MASQ,KATRA,IASyDA,EAA3D6E,IAAgB6M,OATd1R,MASoB,KATpBA,IASyDA,EAA3D6E,OAA4BgJ,OAT1B7N,MASmC,EATnCA,IASyDA,EAA3D6E,MAA2CsL,OATzCnQ,MASiD,KATjDA,EAUArD,EAAOwT,GAAgBnQ,EAAOrD,OAASqb,EAAW,GAAKlS,GACvDuD,EAAgBG,EAAW7M,EAAMkI,GAEjCI,EAA4B,CAChCqB,KAAMA,EAAKyJ,KAAOA,EAClBpT,KAAM2J,EAAKqD,UAAYhN,EACvB+U,IAAKpL,EAAKoL,IAAMoD,GAAYpD,GAC5BvB,QACA8H,OAAQ3R,EAAKR,GAAKA,MAEpBQ,EAAKzB,OAASA,EACdyB,EAAK+C,cAAgBA,EACrB/C,EAAKgI,cAAgBtO,EACrBsG,EAAK4R,KAAQhZ,mBAAiBA,EAAGoH,IACjCA,EAAKuJ,QAAU,kBAAMxG,EAAcC,WAC9B0O,EAAU,CACb1R,EAAK6R,UAAaC,mBAChB5E,EAAa4E,GACN9R,EAAKuE,MACVtG,EAAW6T,GACPA,EACCnH,YACKmH,EAASpV,MACXoV,EAASpV,KAAKiO,MAK1B3K,EAAK4M,GAAoB,kBAAM5M,OACzB+D,EAAWqB,KACbrB,IAAUpF,EAAKkN,eAAiB9H,UAEtCoE,GAAWZ,EACJ5I,GAEIwH,GAAoB0D,mBAAkBjV,EAAY,CAACiV,WAE1DjF,GAAoB,SAACtG,EAAWE,EAASiE,EAAS7J,GAA9B,OACxBmT,GAAezN,EAAME,EAAI,CACvBE,MAAO,CAAC9F,MACRyF,KAAM,CAACX,EAAa,CAAC9E,GAAImM,MACzBpG,KAAM,CAAC8D,SAGLqC,GAAwB,SAACnQ,EAAY8N,EAAY7J,EAASyF,OAC1D3E,EACAsE,EAASpF,KACXc,EAASd,EACTA,EAAKA,EAAGA,QAEJ8L,EAAS9P,EAAYgb,GAASjb,EAAO,cAAU+E,UACrDqS,GAAepX,EAAO+P,EAAQ,CAC5BhG,MAAO,CAAC9F,MACRyF,OACAM,KAAM,CAAC8D,QAEFiC,GAoPHmB,GAAc,SAClBvH,EACA7J,EACAgO,EACAsP,EACAnZ,EACAkN,OAEMkM,EAAWvK,GAAchT,GACzB4J,EAAO,CACXX,EAAS,CAACjJ,MAAOud,EAAUxT,GJtXV,MIuXjBd,EAAa,CACX9E,GAAImZ,EAAa/F,GAAgBK,KAEnC3O,EAAWuH,UACXvH,EAAW7H,QAAQ,CAACpB,MAAOud,IAC3BlM,GACEpI,EAAY,CACV9E,GAAI,SAACqP,EAAQnP,EAAT,OAAaoP,EAAb,EAAaA,EAAb,OAAoBpC,EAAamC,EAAQC,MAEjDxK,GAAY,CAACjJ,MAAOud,KAEhBjO,EAAWqB,QACbrB,IACF1F,EAAKuJ,QAAQ7D,EAAS4D,QACtBtJ,EAAKpG,KAAK8L,EAASsB,QACfvC,EAASxE,IAAO,KACZ2T,EAAMxK,GAAcnJ,GACrBjG,GAAS0L,EAASsC,MAAO4L,KAIvB5Z,GAAS0L,EAASkI,QAASgG,IAC9BlO,EAASkI,QAAQhU,KAAKga,GAEnBD,EAAStK,SAAQsK,EAAStK,OAAS,IACxCsK,EAAStK,OAAOzP,KAAK,CACnB6G,KAAM,UACNiJ,GAAIkK,YASLlG,GAAezN,EAAM7J,EAAO,CACjCiK,MAAO,CAAC9F,MACRyF,OACAM,KAAM,CAAC8D,SC9VLoG,GAAcjQ,mBAAkB+K,mBAAgB/K,2BAAM+K,MAEtDmF,GAAmB,SACvB/M,EACAyH,EACA9J,EACAd,OAEMsZ,EAAQnW,EAAW4H,mBAAcA,EAAKiF,SAAWpF,kCAAkBA,IACnE+B,EAAoBxJ,EAAU,GAAK,GACnCgI,EAAWqB,KACX+M,EAAWD,EAAM3M,GACjB6M,EAAWpM,GAAemM,GAC1BE,EAAUrM,GAAe,GAC/BoM,EAAStT,KAAO/C,EAAU,OAAS,QAC/BgI,GACFA,EAASsC,MAAMpO,KAAKma,EAAUC,OAE1B5d,EAAQC,EAAYyd,EAAU,CAClC9b,KAAMqD,GAAkBgJ,EAAec,KAEzC3C,GAASpM,GAAOkK,KAAK2T,UAAY,MAC3BjU,EAAO,CACXX,EAAWuH,UACXvH,EAAS,CACPjJ,MAAO2d,EACP5T,GL1Fe,MK6FjBd,EAAY,CACV9E,GAAI,SAAC+R,EAAD,SAAO9H,EAAP,EAAOA,IAAP,OAAqB8H,IAArB,EAAczC,EAAiBrF,MAErCnF,EAAS,CACPjJ,MAAO4d,EACP7T,GAAI,MAENd,EAAa,CACX9E,GADW,SACR+R,EADQ,EACWtL,OAAb6S,EAAa7S,EAAd6S,MAAQrP,EAAMxD,EAAd6S,IACF7S,EAAIsP,IACNtP,EAAI6I,EAAIgK,EAAM7S,EAAI6I,IAEpB7I,EAAI6I,EAAErF,GAAO8H,KAGjBjN,EAAS,CACPY,KL7Ge,IK8GfjF,OAAQ+Y,IAEV1U,EAAS,CACPY,KLrHe,QKsHf7J,MAAO,EACP4E,OAAQgZ,IAEV3U,EAAa,CAACmE,SL1HK,YK2HnBnE,EAAS,CACPY,KL3He,QK4Hf7J,MAAO,EACP4E,OAAQgZ,IAEV3U,EAAS,CAACjJ,MAAO2d,IACjBxZ,GAAM8E,EAAa,CAAC9E,OACpB8E,EAAW7H,QAAQ,CACjBpB,MAAOgT,GAAchT,MAGnBiT,EAAiB0K,EAAS1K,OAAS,UACzCnE,EAAMC,GAAK,SAAC/E,EAAyBoE,MAC9BC,EAASrE,GADqBoE,CAKnC0C,EAAa1C,GAAOpE,EAAM8G,aAC1B4M,EAAStP,GAAOpE,EAAMiI,eAChBc,EAAWuE,GAAetN,EAAOhK,EAAO,CAC5CiK,MAAO,CAACmE,MAAKqP,SACb7T,OACAM,KAAM,CAAC8D,GAAI,aAEP8P,EAAW9K,GAAchJ,GAC/BiJ,EAAOzP,KAAK,CACV6G,KAAM,QACNzH,MAAOwL,EACPvE,KAAMiU,IAEJxO,IACG1L,GAAS0L,EAASsC,MAAOkM,IAC5B/K,EAASpI,IAAIwI,QAAQ7D,EAAS4D,cAlBhCwK,EAAStP,GAAO0C,EAAa1C,GAAOpE,KAuBxChK,EAAM+d,aAAehP,EACrB4O,EAAShM,MAAQ,CACfxN,EACI,CACEkG,KAAM+F,EACNrG,GAAIiJ,GAAchT,GAClBmE,MAEF,CACEkG,KAAM,OACNN,GAAIiJ,GAAchT,KAGrBsP,IACHtP,EAAM8Q,aAAe3M,EAChB6O,GAAchT,GAAO8N,QAAU3J,EAAGuZ,GACnC5M,GAEC9Q,GE1BI4V,GAAY,SAAC,GAAD,IACvB7J,EADuB,EACvBA,OACAwI,EAFuB,EAEvBA,IACAsB,EAHuB,EAGvBA,GACAX,EAJuB,EAIvBA,OACArI,EALuB,EAKvBA,MALuB,OAelBI,mBACL3B,EAAO,CACL1G,OAAQ,CAACsQ,EAAQ8I,IACjBjS,OAAQ,CACN8J,EACI,CACER,OAAQ,OACRtJ,SACAxI,OAAQ0J,GAEV,CACEoI,OAAQ,OACRtJ,SACAnG,MAAOqH,GAEb,CACE9I,GAAI0R,EAAKtB,EAAIE,GAAKF,EAAIG,GACtB3T,MAAOkM,IAGXjB,MAAO,EACPC,KAAMY,EAAMZ,KACZH,SAAUI,GAAYW,OAGbmR,GAAYrU,EAAW,CAClCC,KAAM,CACJX,EAAS,CACP9E,GADO,aAELA,EADMpD,EAALoD,IAAKpD,EAALoD,WAKP+F,KAAM,CAAC8D,GAAI,KAAMgI,GAAI,eE9LjBgB,GAAqB,CAAC,SAAU,QAAS,W,2FmBbxC,SAASpQ,EAAgB5G,GACzBqO,IAAGrO,MAAMA,IAAQyJ,EAAW,8CAE3BwU,EAAeje,EAAMiS,WACrBiM,EAAMC,EAAMC,YAAYxV,mBAAyBA,EAAI,IAAG,GAAG,GAC3DyV,EAAeF,EAAMG,OAAO,CAChCte,QACAe,MAAOkd,EACP1H,QAAS,WAEXgI,GAA0B,eAClBjS,EAAOtM,EAAMyR,QAAQ3B,OAAMoG,gBACzBsH,EAAMa,EAAavQ,QACpB0P,EAAIjH,UACPiH,EAAIzc,MAAQmV,EACZsH,EAAIjH,QAAU,EACd2H,IACAV,EAAIjH,QAAU,MAGZiI,EAAWxe,EAAMiS,WACjBuL,EAAMa,EAAavQ,eACrB0P,EAAIxd,QAAUA,GAASwd,EAAIzc,QAAUyd,IACvChB,EAAIzc,MAAQyd,EACZhB,EAAIjH,QAAU,EACd2H,IACAV,EAAIjH,QAAU,GAEhBiH,EAAIxd,MAAQA,EACLsM,IACN,CAACtM,IACGie,EClCF,IAAMM,EACO,oBAAXE,OAAyBN,EAAMO,gBAAkBP,EAAMQ,UCHnDlV,EAAc8O,kBACnBC,MAAMD,K,gCCDd,8CACe,SAASqG,EAA4BrW,EAAGsW,GACrD,GAAKtW,EAAL,CACA,GAAiB,kBAANA,EAAgB,OAAO,YAAiBA,EAAGsW,GACtD,IAAIjW,EAAInB,OAAOqX,UAAUtQ,SAASuQ,KAAKxW,GAAG4L,MAAM,GAAI,GAEpD,MADU,WAANvL,GAAkBL,EAAEyW,cAAapW,EAAIL,EAAEyW,YAAYpd,MAC7C,QAANgH,GAAqB,QAANA,EAAoBvB,MAAMwC,KAAKtB,GACxC,cAANK,GAAqB,2CAA2CqW,KAAKrW,GAAW,YAAiBL,EAAGsW,QAAxG,K,0FCHa,SAASK,EAAmB9X,GACzC,OCJa,SAA4BA,GACzC,GAAIC,MAAMC,QAAQF,GAAM,OAAO,OAAA+X,EAAA,GAAiB/X,GDGzC,CAAkBA,IELZ,SAA0BgY,GACvC,GAAsB,qBAAX7X,QAA0BA,OAAOC,YAAYC,OAAO2X,GAAO,OAAO/X,MAAMwC,KAAKuV,GFIvD,CAAgBhY,IAAQ,OAAAgB,EAAA,GAA2BhB,IGLvE,WACb,MAAM,IAAIiB,UAAU,wIHIwE,K,gCIL/E,SAASgX,EAAkBjY,EAAKkY,IAClC,MAAPA,GAAeA,EAAMlY,EAAI/D,UAAQic,EAAMlY,EAAI/D,QAE/C,IAAK,IAAID,EAAI,EAAGmc,EAAO,IAAIlY,MAAMiY,GAAMlc,EAAIkc,EAAKlc,IAC9Cmc,EAAKnc,GAAKgE,EAAIhE,GAGhB,OAAOmc,EAPT","file":"static/js/0.dcd09486.chunk.js","sourcesContent":["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n  init: Value\n  domain?: Domain\n  existing?: Store<Value>\n}\n\nfunction store<Value>({ init, domain, existing }: CreateStoreParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.store(init) : createStore(init)\n}\n\ntype CreateEventParams<Value> = {\n  domain?: Domain\n  existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n","import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine, \n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldData,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n    RuleResolver,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    })\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    })\n    \n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $isDirty = $value.map((value) => value !== initValue)\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    })\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string \n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    const $isValid = $firstError.map((firstError) => firstError === null)\n\n    const $field = combine({\n        value: $value,\n        errors: $errors,\n        firstError: $firstError,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        isTouched: $touched,\n    })\n\n    return {\n        changed,\n        name: fieldName,\n        $value,\n        $errors,\n        $firstError,\n        $isValid,\n        $isDirty,\n        $isTouched: $touched,\n        $touched,\n        $field: $field as Store<FieldData<any>>,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        filter: fieldConfig.filter,\n    }\n}\n\ntype BindValidationParams = {\n  $form: Store<AnyFormValues>\n  validateFormEvent: Event<void>\n  submitEvent: Event<void>\n  resetFormEvent: Event<void>\n  resetValues: Event<void>\n  resetErrors: Event<void>\n  field: Field<any>\n  rules: Rule<any, any>[] | RuleResolver<any, any>\n  formValidationEvents: ValidationEvent[]\n  fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    validateFormEvent,\n    submitEvent,\n    resetFormEvent,\n    resetValues,\n    field,\n    rules,\n    resetErrors: resetErrorsFormEvent,\n    formValidationEvents,\n    fieldValidationEvents,\n}: BindValidationParams): void {\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\" \n        ? createStore<any[]>([])\n        : combine(rules.map(({ source }) => source || createStore(null)))\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        const validationTrigger = sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: submitEvent,\n        })\n\n        validationEvents.push(validationTrigger)\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validateFormEvent,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),  \n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .reset(resetErrors, resetFormEvent, reset, resetErrorsFormEvent)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\nexport function bindChangeEvent(\n    {\n        $value,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue, \n        filter }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n    resetForm: Event<void>,\n    resetTouched: Event<void>,\n    resetValues: Event<void>,\n): void {\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name) \n                ? updateSet[name] \n                : curr\n        )\n        .reset(reset, resetValue, resetValues, resetForm)\n    \n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n            ? rulesOrResolver(value, form)\n            : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n} from \"effector\"\nimport {\n    FieldConfig,\n    Field,\n    AnyFields,\n    AnyFieldsConfigs,\n    AnyFormValues,\n    FormConfig,\n    FormValues,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\n\nexport type Form<Fields extends AnyFieldsConfigs> = {\n  fields: {\n    [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n      ? Field<U>\n      : never\n  }\n  $values: Store<FormValues<Fields>>\n  $eachValid: Store<boolean>\n  $isValid: Store<boolean>\n  $isDirty: Store<boolean>\n  $touched: Store<boolean>\n  $meta: Store<{\n    isValid: boolean\n    isDirty: boolean\n    touched: boolean\n  }>\n  submit: Event<void>\n  validate: Event<void>\n  reset: Event<void>\n  set: Event<Partial<FormValues<Fields>>>\n  setForm: Event<Partial<FormValues<Fields>>>\n  resetTouched: Event<void>\n  resetValues: Event<void>\n  resetErrors: Event<void>\n  formValidated: Event<FormValues<Fields>>\n}\n\n\nexport function createForm<Fields extends AnyFieldsConfigs>(\n    config: FormConfig<Fields>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n \n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        const field = createField(fieldName, fieldConfig, domain)\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const $meta = combine({\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n    })\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n  \n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n    \n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n    \n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n    \n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n    \n    const submitWithFormData = sample($form, submitForm)\n    const validateWithFormData = sample($form, validate)\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(field, setForm, resetForm, resetTouched, resetValues)\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            resetFormEvent: resetForm,\n            resetValues,\n            resetErrors,\n            validateFormEvent: validate,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn \n                : [],\n        })\n    }\n\n    guard({\n        source: submitWithFormData,\n        filter: $isFormValid,\n        // TODO: fix\n        target: formValidated as unknown as Event<AnyFormValues>,\n    })\n\n    guard({\n        source: validateWithFormData,\n        filter: $isFormValid,\n        target: formValidated as unknown as Event<AnyFormValues>,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $eachValid,\n        $isValid: $eachValid,\n        $isDirty: $isDirty,\n        $touched: $touched,\n        $meta,\n        submit: submitForm,\n        validate,\n        resetTouched,\n        reset: resetForm,\n        resetValues,\n        resetErrors,\n        setForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Fields>\n}\n","import { useStore } from \"effector-react\"\nimport { Event } from \"effector\"\nimport { Form } from \"./factory\"\nimport {\n    Field,\n    FormValues,\n    ValidationError,\n    FieldConfig,\n    AnyFieldsConfigs,\n    AnyFormValues\n} from \"./types\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: Event<Value>\n  onBlur: Event<void>\n  errorText: (map?: ErrorTextMap) => string\n  addError: Event<{ rule: string; errorText?: string }>\n  validate: Event<void>\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  reset: Event<void>\n  set: Event<Value>\n  resetErrors: Event<void>\n}\n\ntype ConnectedFields<Fields extends AnyFieldsConfigs> = {\n  [K in keyof Fields]: Fields[K] extends FieldConfig<infer U>\n  ? ConnectedField<U>\n  : never\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const {\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        isTouched: touched,\n    } = useStore(field.$field)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: field.onChange,\n        onBlur: field.onBlur,\n        addError: field.addError,\n        validate: field.validate,\n        reset: field.reset,\n        set: field.onChange,\n        resetErrors: field.resetErrors,\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Fields extends AnyFieldsConfigs> = {\n  fields: ConnectedFields<Fields>\n  values: FormValues<Fields>\n  hasError: (fieldName?: keyof Fields) => boolean\n  eachValid: boolean\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  errors: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U>[] : never\n  )\n  error: (fieldName: keyof Fields) => (\n    // eslint-disable-next-line max-len\n    Fields[typeof fieldName] extends FieldConfig<infer U> ? ValidationError<U> : never\n  ) | null\n  errorText: (fieldName: keyof Fields, map?: ErrorTextMap) => string\n  submit: Event<void>\n  reset: Event<void>\n  setForm: Event<Partial<FormValues<Fields>>>\n  set: Event<Partial<FormValues<Fields>>>\n  formValidated: Event<FormValues<Fields>>\n}\n\nexport function useForm<Fields extends AnyFieldsConfigs>(\n    form: Form<Fields>\n) {\n    const connectedFields = {} as AnyConnectedFields\n    const values = {} as AnyFormValues\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue \n        const field = form.fields[fieldName]\n        const connectedField = useField(field)\n        connectedFields[fieldName] = connectedField\n        values[fieldName] = connectedField.value\n    }\n\n    const {\n        isValid: eachValid,\n        isDirty,\n        touched,\n    } = useStore(form.$meta)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Fields>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        reset: form.reset,\n        errorText,\n        submit: form.submit,\n        setForm: form.setForm,\n        set: form.setForm, // set form alias\n        formValidated: form.formValidated,\n    } as Result<Fields>\n}\n","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' â†’ *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' â†’? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* â†’ ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        É”: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        É”: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.É”\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}É”${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n","import {Store, is, clearNode, createStore} from 'effector'\nimport React from 'react'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {throwError} from './throw'\n\nexport function useStore<State>(store: Store<State>): State {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const currentValue = store.getState()\n  const inc = React.useReducer((n: any, action: void) => n + 1, 0)[1]\n  const currentStore = React.useRef({\n    store,\n    value: currentValue,\n    pending: false,\n  })\n  useIsomorphicLayoutEffect(() => {\n    const stop = store.updates.watch(upd => {\n      const ref = currentStore.current\n      if (!ref.pending) {\n        ref.value = upd\n        ref.pending = true\n        inc()\n        ref.pending = false\n      }\n    })\n    const newValue = store.getState()\n    const ref = currentStore.current\n    if (ref.store === store && ref.value !== newValue) {\n      ref.value = newValue\n      ref.pending = true\n      inc()\n      ref.pending = false\n    }\n    ref.store = store\n    return stop\n  }, [store])\n  return currentValue\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = ([] as unknown) as Keys\n  } else {\n    fn = (configOrStore as any).fn\n    store = (configOrStore as any).store\n    keys = (configOrStore as any).keys\n    updateFilter = (configOrStore as any).updateFilter\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n  const result: Store<Result> = React.useMemo(\n    () =>\n      createStore(fn(store.getState(), keys), {updateFilter}).on(\n        store,\n        (_, state) => fn(state, keys),\n      ),\n    keys,\n  )\n  const state = useStore(result)\n  useIsomorphicLayoutEffect(\n    () => () => {\n      result.off(store)\n      clearNode(result, {deep: true})\n    },\n    keys,\n  )\n  return state\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}"],"sourceRoot":""}